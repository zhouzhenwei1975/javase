package net.zzw.javase.foundational.operator.bit;

/**
 * 有符号右移的使用
 *
 * @author zzw dgzzw1@163.com
 * @version 2021/12/12 下午4:22
 * @since JDK11
 */
public class SignedRightMoveOperator {
	public static void main(String[] args) {
		// 有符号右移(>>)内存中的操作过程：二进制补码向右移动，右边丢弃，左边使用符号位来补齐，符号位是1，那么就补1，如果符号位是0，那么就补0
		// 有符号右移(>>)运算规律：右移N位，就是除以2的N次方

		/*
			正整数 右移的内存操作过程
			1.整数32默认占据4个字节，二进制的补码表示为	0000 0000 0000 0000 0000 0000 0010 0000
			2. 0000 0000 0000 0000 0000 0000 0010 0000 >> 2
		右移两位的结果 	00 0000 0000 0000 0000 0000 0000 0010 00
			3.转换成十进制的原码输出
			10 00 转换成十进制的结果是8
		 */
		System.out.println("32 >> 2 = " + (32 >> 2));


		/*
			负整数 右移的内存操作过程
			1.负整数-32默认占据4个字节，因为是int类型，二进制的原码表示方式为	1000 0000 0000 0000 0000 0000 0010 0000
			2.根据原码求补码
			原码：1000 0000 0000 0000 0000 0000 0010 0000
			反码：1111 1111 1111 1111 1111 1111 1101 1111
			补码: 1111 1111 1111 1111 1111 1111 1110 0000
			3.将  1111 1111 1111 1111 1111 1111 1110 0000 >> 2
	右移两位结果    111111 1111 1111 1111 1111 1110 00
			4.根据补码求原码
			补码：111111 1111 1111 1111 1111 1110 00 减1得如下反码
			反码: 111111 1111 1111 1111 1111 1101 11 符号位不变，其他位取反，得出如下原码
			原码: 100000 0000 0000 0000 0000 0010 00 = -8
		 */
		System.out.println("-32 >> 2 = " + (-32 >> 2));
	}
}

package net.zzw.javase.foundational.operator.bit;

/**
 * 按位取反的使用
 *
 * @author zzw dgzzw1@163.com
 * @version 2021/12/12 下午3:19
 * @since JDK11
 */
public class BitNotOperator {
	public static void main(String[] args) {
		// 按位取反是一个单目运算符(一元运算符)，只能操作一个变量或者表达式

		/*
			计算过程
			245 默认是四个字节的内存，在内存中的二进制补码表示为	0000 0000 0000 0000 0000 0000 1111 0101
			0000 0000 0000 0000 0000 0000 1111 0101
		  ~ 1111 1111 1111 1111 1111 1111 0000 1010
		  	补码转换成原码的过程
		  	1.补码转换成反码，补码减1，结果是
		  	1111 1111 1111 1111 1111 1111 0000 1001
		  	2.反码转换成原码，最高位不变，其他位取反
		  	1000 0000 0000 0000 0000 0000 1111 0110 = -246
		 */
		System.out.println("有符号的正整数245按位取反的结果是" + (~245));

		/*
			负整数的按位取反的计算过程
			-245 原码	1000 0000 0000 0000 0000 0000 1111 0101
			-245 反码    1111 1111 1111 1111 1111 1111 0000 1010
			-245 补码    1111 1111 1111 1111 1111 1111 0000 1011 在内存中补码的表示 (负数补码=反码+1）
			对补码进行取反 0000 0000 0000 0000 0000 0000 1111 0100 = 244
		 */
		System.out.println("有符号的负整数245按位取反的结果是" + (~ -245));

	}
}

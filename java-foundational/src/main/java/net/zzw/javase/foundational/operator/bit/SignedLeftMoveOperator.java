package net.zzw.javase.foundational.operator.bit;

/**
 * 有符号左移运算符的使用
 *
 * @author zzw dgzzw1@163.com
 * @version 2021/12/12 下午3:50
 * @since JDK11
 */
public class SignedLeftMoveOperator {

	public static void main(String[] args) {
		// 有符号左移(<<)内存中的操作过程：二进制补码向左移动，左边的的符号位会丢弃，右边补0
		// 有符号左移(<<)运算规律：左移N位，就是乘以2的N次方

		/*
			正整数 左移的内存操作过程
			1. 10是占据4个字节，因为默认是int类型，计算二进制补码	0000 0000 0000 0000 0000 0000 0000 1010
			2.位运算符操作的是二进制补码 0000 0000 0000 0000 0000 0000 0000 1010 << 2
			3.向左移动的结果	00 0000 0000 0000 0000 0000 0000 101000
			4.打印输出需要转换成十进制的原码 40
		 */
		System.out.println("10 << 2 = " + (10 << 2));


		/*
			负整数 左移的内存操作过程
			1.-10的原码	1000 0000 0000 0000 0000 0000 0000 1010
			2.-10的反码  1111 1111 1111 1111 1111 1111 1111 0101 （负数的补码 = 反码 + 1，得出如下结果)
			3.-10的补码  1111 1111 1111 1111 1111 1111 1111 0110 << 2
			4.向左移动的结果 11 1111 1111 1111 1111 1111 1111 011000 是以补码存在，再将该补码还原为原码
			5.补码：11 1111 1111 1111 1111 1111 1111 011000 （补码-1）得出以下反码
			6.反码：11 1111 1111 1111 1111 1111 1111 010111  (反码得出原码，符号不变，其他位取反，得出如下原码
			7.原码：10 0000 0000 0000 0000 0000 0000 101000 = 十进制原码 8 + 32 = -40
		 */
		System.out.println("-10 << 2 = " + (-10 << 2));
	}
}
